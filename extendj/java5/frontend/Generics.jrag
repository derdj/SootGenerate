/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2014, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

aspect Generics {

  /**
   * Qualified access for wildcard types.
   * Since they have no ordinary package and type name
   * we just return the bound access.
   */
  public Access AbstractWildcardType.createQualifiedAccess() {
    return createBoundAccess();
  }

  eq ParClassDecl.hostType() = original();
  eq ParInterfaceDecl.hostType() = original();
  eq RawClassDecl.hostType() = original();
  eq RawInterfaceDecl.hostType() = original();
  eq ClassDeclSubstituted.hostType() = getOriginal();
  eq InterfaceDeclSubstituted.hostType() = getOriginal();
  eq GenericClassDeclSubstituted.hostType() = getOriginal();
  eq GenericInterfaceDeclSubstituted.hostType() = getOriginal();

  refine TypeAnalysis eq MethodAccess.type() {
    if (getNumArg() == 0 && name().equals("getClass") && decl().hostType().isObject()) {
      TypeDecl typeClass = lookupType("java.lang", "Class");
      if (typeClass instanceof GenericClassDecl) {
        TypeDecl bound = isQualified() ? qualifier().type() : hostType();
        ArrayList<TypeDecl> args = new ArrayList<TypeDecl>();
        args.add(bound.erasure().asWildcardExtends());
        return ((GenericClassDecl) typeClass).lookupParTypeDecl(args);
      }
    }
    // Legacy getClass access using non-generic java.lang.Class.
    return refined();
  }

  // Imported types are considered raw types by the name resolver
  // here we replace them by their generic counter parts.
  refine TypeScopePropagation eq CompilationUnit.getChild().lookupType(String name) {
    SimpleSet result = SimpleSet.emptySet;
    for (Iterator iter = refined(name).iterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl) iter.next();
      if (typeDecl instanceof ParTypeDecl) {
        result = result.add(((ParTypeDecl) typeDecl).genericDecl());
      } else {
        result = result.add(typeDecl);
      }
    }
    return result;
  }

  refine TypeConversion eq ClassDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T instanceof TypeVariable) {
      TypeVariable t = (TypeVariable) T;
      if (t.getNumTypeBound() == 0) {
        return true;
      }
      for (int i = 0; i < t.getNumTypeBound(); i++) {
        if (castingConversionTo(t.getTypeBound(i).type())) {
          return true;
        }
      }
      return false;
    }
    if (T.isClassDecl() && (S.erasure() != S || T.erasure() != T)) {
        return S.erasure().castingConversionTo(T.erasure());
    }
    return refined(type);
  }

  refine TypeConversion eq InterfaceDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T.isArrayDecl()) {
      return T.instanceOf(S);
    } else if (T.isReferenceType() && !T.isFinal()) {
      return true;
    } else {
      return T.instanceOf(S);
    }
  }

  eq TypeVariable.castingConversionTo(TypeDecl type) {
    if (!type.isReferenceType()) {
      return false;
    }
    if (getNumTypeBound() == 0) {
      return true;
    }
    for (int i = 0; i < getNumTypeBound(); i++) {
      if (getTypeBound(i).type().castingConversionTo(type)) {
        return true;
      }
    }
    return false;
  }

  refine TypeConversion eq ArrayDecl.castingConversionTo(TypeDecl type) {
    TypeDecl S = this;
    TypeDecl T = type;
    if (T instanceof TypeVariable) {
      TypeVariable t = (TypeVariable) T;
      if (!type.isReferenceType()) {
        return false;
      }
      if (t.getNumTypeBound() == 0) {
        return true;
      }
      for (int i = 0; i < t.getNumTypeBound(); i++) {
        TypeDecl bound = t.getTypeBound(i).type();
        if (bound.isObject() || bound == typeSerializable() || bound == typeCloneable()) {
          return true;
        }
        if (bound.isTypeVariable() && castingConversionTo(bound)) {
          return true;
        }
        if (bound.isArrayDecl() && castingConversionTo(bound)) {
          return true;
        }
      }
      return false;
    } else {
      return refined(type);
    }
  }

  refine TypeAnalysis eq ClassAccess.type() {
    TypeDecl decl = refined();
    if (decl instanceof GenericClassDecl) {
      GenericClassDecl d = (GenericClassDecl) refined();
      TypeDecl type = qualifier().type();
      if (type.isPrimitiveType()) {
        type = type.boxed();
      }
      ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
      list.add(type);
      return d.lookupParTypeDecl(list);
    }
    // Using non-generic java.lang.Class
    return decl;
  }

  refine AutoBoxing eq ConditionalExpr.type() {
    TypeDecl type = refined();
    TypeDecl trueType = getTrueExpr().type();
    TypeDecl falseType = getFalseExpr().type();

    if (type.isUnknown()) {
      if (!trueType.isReferenceType() && !trueType.boxed().isUnknown()) {
        trueType = trueType.boxed();
      }
      if (!falseType.isReferenceType() && !falseType.boxed().isUnknown()) {
        falseType = falseType.boxed();
      }

      ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
      list.add(trueType);
      list.add(falseType);
      return type.lookupLUBType(list);
    }
    return type;
  }

  syn boolean TypeVariable.isNestedType() = false;

  // Accessibility for members in generic classes.  The accessibility for
  // parameterized and raw versions of a generic class should be the same as
  // for the generic class, in other words the erasure of the paramterized
  // version.
  eq ParClassDecl.topLevelType() = erasure().topLevelType();

  interface GenericTypeDecl {
    syn boolean isGenericType();
    TypeDecl original();
    int getNumTypeParameter();
    TypeVariable getTypeParameter(int index);
    List<TypeVariable> getTypeParameterList();
    syn lazy TypeDecl rawType();
    public String fullName();
    public String typeName();
  }

  GenericClassDecl implements GenericTypeDecl;
  GenericInterfaceDecl implements GenericTypeDecl;

  eq GenericClassDecl.rawType() = lookupParTypeDecl(Collections.<TypeDecl>emptyList());

  eq GenericInterfaceDecl.rawType() = lookupParTypeDecl(Collections.<TypeDecl>emptyList());

  syn boolean TypeDecl.isGenericType() = false;

  eq GenericTypeDecl.isGenericType() = true;

  // Brute force replacesment with generic one in AST
  // make sure that the AST has not beed traversed yet!
  public TypeDecl TypeDecl.makeGeneric(Signatures.ClassSignature s) {
    return this;
  }

  public TypeDecl ClassDecl.makeGeneric(Signatures.ClassSignature s) {
    // NOTE: we are overwriting List- and Opt- children here using setSuperClassOpt
    // and setImplementsList. This is dangerous since those children are in some
    // cases NTAs, and we should not use set methods to try to overwrite NTA values.
    // However, we have to do this here in order to not trigger rewrites that in
    // turn need to access certain (inherited) lookup attributes, and we are reasonably
    // sure that we are in fact not overwriting NTA children. We exclude EnumDecl here
    // because its [SuperClass] and Implements* are in fact NTAs.
    // /Jesper 2015-01-22
    if (this instanceof EnumDecl) {
      return this; // Enum superclass and superinterfaces are NTAs.
    }
    if (s.hasFormalTypeParameters()) {
      ASTNode node = getParent();
      int index = node.getIndexOfChild(this);
      node.setChild(
          new GenericClassDecl(
            getModifiersNoTransform(),
            getID(),
            s.hasSuperclassSignature()
                ? new Opt(s.superclassSignature())
                : getSuperClassOptNoTransform(),
            s.hasSuperinterfaceSignature()
                ? s.superinterfaceSignature()
                : getImplementsListNoTransform(),
            getBodyDeclListNoTransform(),
            s.typeParameters()
          ),
          index
      );
      return (TypeDecl) node.getChildNoTransform(index);
    } else {
      if (s.hasSuperclassSignature()) {
        setSuperClassOpt(new Opt(s.superclassSignature()));
      }
      if (s.hasSuperinterfaceSignature()) {
        setImplementsList(s.superinterfaceSignature());
      }
      return this;
    }
  }

  public TypeDecl InterfaceDecl.makeGeneric(Signatures.ClassSignature s) {
    if (s.hasFormalTypeParameters()) {
      ASTNode node = getParent();
      int index = node.getIndexOfChild(this);
      node.setChild(
          new GenericInterfaceDecl(
            getModifiersNoTransform(),
            getID(),
            s.hasSuperinterfaceSignature()
                ? s.superinterfaceSignature()
                : getSuperInterfaceListNoTransform(),
            getBodyDeclListNoTransform(),
            s.typeParameters()
          ),
          index
      );
      return (TypeDecl) node.getChildNoTransform(index);
    } else {
      if (s.hasSuperinterfaceSignature()) {
        setSuperInterfaceList(s.superinterfaceSignature());
      }
      return this;
    }
  }

  public TypeDecl GenericTypeDecl.makeGeneric(Signatures.ClassSignature s) {
    return (TypeDecl) this;
  }

  interface ParTypeDecl {
    //syn String name();
    int getNumArgument();
    Access getArgument(int index);
    syn boolean isParameterizedType();
    syn boolean isRawType();
    public String typeName();
    SimpleSet localFields(String name);
    Map<String,SimpleSet> localMethodsSignatureMap();
  }

  ParClassDecl implements ParTypeDecl;
  ParInterfaceDecl implements ParTypeDecl;

  syn boolean TypeDecl.isParameterizedType() = false;
  eq ParTypeDecl.isParameterizedType() = true;

  syn boolean TypeDecl.isRawType() = isNestedType() && enclosingType().isRawType();
  eq ParClassDecl.isRawType() = isNestedType() && enclosingType().isRawType();
  eq ParInterfaceDecl.isRawType() = isNestedType() && enclosingType().isRawType();
  eq RawClassDecl.isRawType() = true;
  eq RawInterfaceDecl.isRawType() = true;
}

aspect GenericsTypeAnalysis {
  eq ParTypeAccess.unqualifiedScope() =
      getParent() instanceof Access
      ? ((Access) getParent()).unqualifiedScope()
      : super.unqualifiedScope();

  eq ParTypeAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);

  eq Program.getChild().inExtendsOrImplements() = false;
  eq ClassDecl.getSuperClass().inExtendsOrImplements() = true;
  eq ClassDecl.getImplements(int i).inExtendsOrImplements() = true;
  eq InterfaceDecl.getSuperInterface().inExtendsOrImplements() = true;
  inh boolean Expr.inExtendsOrImplements();

  eq ParTypeAccess.type() {
    TypeDecl typeDecl = genericDecl();
    if (typeDecl instanceof GenericTypeDecl) {
      // Use signature in lookup for types that are used in extends and implements clauses.
      if (unqualifiedScope().inExtendsOrImplements()) {
        return ((GenericTypeDecl) typeDecl).lookupParTypeDecl(this);
      }
      ArrayList<TypeDecl> args = new ArrayList<TypeDecl>();
      for (int i = 0; i < getNumTypeArgument(); i++) {
        args.add(getTypeArgument(i).type());
      }
      return ((GenericTypeDecl) typeDecl).lookupParTypeDecl(args);
    }
    return typeDecl;
  }

  syn TypeDecl ParTypeAccess.genericDecl() = getTypeAccess().type();

  eq ParTypeAccess.isTypeAccess() = true;

  refine TypeScopePropagation eq TypeAccess.decl() {
    TypeDecl decl = refined();
    if (decl instanceof GenericTypeDecl && isRaw()) {
      return ((GenericTypeDecl) decl).lookupParTypeDecl(Collections.<TypeDecl>emptyList());
    }
    return decl;
  }

  /** This method assumes that the bound type is generic. */
  public boolean TypeAccess.isRaw() {
    /*
    if (hasNextAccess()) {
      return false;
    }
    */
    ASTNode parent = getParent();
    while (parent instanceof AbstractDot) {
      parent = parent.getParent();
    }
    if (parent instanceof ParTypeAccess) {
      return false;
    }
    if (parent instanceof ImportDecl) {
      return false;
    }
    /*
    Access a = this;
    while (a.isTypeAccess() && hasNextAccess()) {
      a = a.nextAccess();
    }
    if (a.isThisAccess() || a.isSuperAccess()) {
      return false;
    }
    */
    return true;
  }

  refine TypeScopePropagation eq ThisAccess.decl() {
    TypeDecl typeDecl = refined();
    if (typeDecl instanceof ParTypeDecl) {
      typeDecl = ((ParTypeDecl) typeDecl).genericDecl();
    }
    return typeDecl;
  }
  refine TypeScopePropagation eq SuperAccess.decl() {
    TypeDecl typeDecl = refined();
    if (typeDecl instanceof ParTypeDecl) {
      typeDecl = ((ParTypeDecl) typeDecl).genericDecl();
    }
    return typeDecl;
  }

  public boolean BoundTypeAccess.isRaw() {
    return getTypeDecl().isRawType();
  }
  public boolean ParTypeAccess.isRaw() {
    return false;
  }

}

aspect GenericsErasure {
  syn lazy TypeDecl TypeDecl.erasure() {
    if (isAnonymous() || isLocalClass()) {
      return this;
    }
    if (!isNestedType()) {
      return this;
    }
    return extractSingleType(enclosingType().erasure().memberTypes(name()));
  }
  eq ParClassDecl.erasure() = genericDecl();
  eq ParInterfaceDecl.erasure() = genericDecl();
  eq TypeVariable.erasure() = getTypeBound(0).type().erasure(); // Skip last erasure?
  eq ArrayDecl.erasure() = componentType().erasure().arrayType();
}

aspect GenericsTypeCheck {

  public void ArrayCreationExpr.typeCheck() {
    super.typeCheck();

    if (!type().isReifiable()) {
      error("can not create array with non-reifiable element type");
    }
  }

  refine TypeCheck
  public void InstanceOfExpr.typeCheck() {
    refined();
    if (!getTypeAccess().type().isReifiable()) {
      error("right-hand side of instanceof expression must denote a reifiable type");
    }
  }

  // Different parameterizations of the same generic interface may not be implemented.
  refine TypeHierarchyCheck public void TypeDecl.typeCheck() {
    refined();
    ArrayList<InterfaceDecl> interfaceList = new ArrayList<InterfaceDecl>();
    interfaceList.addAll(implementedInterfaces());
    for (InterfaceDecl decl: interfaceList) {
      if (decl instanceof ParInterfaceDecl) {
        ParInterfaceDecl p = (ParInterfaceDecl) decl;
        for (InterfaceDecl decl2: interfaceList) {
          if (decl2 instanceof ParInterfaceDecl) {
            ParInterfaceDecl q = (ParInterfaceDecl) decl2;
            if (p != q && p.genericDecl() == q.genericDecl() && !p.sameArgument(q)) {
              errorf("%s cannot be inherited with different type arguments: %s and %s",
                  p.genericDecl().name(), p.typeName(), q.typeName());
            }
          }
        }
      }
    }

    // Check if a method has same signature as another in a supertype but does not override it.
    Map<String,SimpleSet> map = erasedAncestorMethodsMap();
    for (Iterator iter1 = localMethodsIterator(); iter1.hasNext(); ) {
      MethodDecl localMethod = (MethodDecl) iter1.next();

      String signature = localMethod.signature();

      SimpleSet set = map.get(signature);
      if (set != null) {
        for (Iterator i2 = set.iterator(); i2.hasNext(); ) {
          MethodDecl decl = (MethodDecl) i2.next();
          if (!decl.signature().equals(signature)) {
            localMethod.errorf("method %s in %s has the same erased signature as"
                + " %s declared in %s but does not override it",
                signature, typeName(), decl.signature(), decl.hostType().typeName());
          }
        }
      }
    }
  }

  syn lazy Map<String,SimpleSet> TypeDecl.erasedAncestorMethodsMap() =
      original().localMethodsSignatureMap();

  eq ClassDecl.erasedAncestorMethodsMap() {
    Map<String,SimpleSet> localMap = localMethodsSignatureMap();
    Map<String,SimpleSet> map = new HashMap<String,SimpleSet>();
    if (hasSuperclass()) {
      for (Iterator<MethodDecl> iter = superclass().localMethodsIterator(); iter.hasNext(); ) {
        MethodDecl m = iter.next();
        if (!m.isPrivate() && m.accessibleFrom(this) && m.erasedMethod() != m) {
          // map erased signature to substituted method
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
      mergeMap(map, superclass().erasedAncestorMethodsMap());
    }
    for (Iterator<MethodDecl> iter = interfacesMethodsIterator(); iter.hasNext(); ) {
      MethodDecl m = iter.next();
      if (m.accessibleFrom(this) && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        // map erased signature to substituted method
        putSimpleSetElement(map, erasedSignature, m);
      }
    }
    return map;
  }

  eq InterfaceDecl.erasedAncestorMethodsMap() {
    Map<String,SimpleSet> localMap = localMethodsSignatureMap();
    Map<String,SimpleSet> map = new HashMap<String,SimpleSet>(localMap);
    for (Iterator<MethodDecl> iter = interfacesMethodsIterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl) iter.next();
      if (m.accessibleFrom(this) && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        if (!localMap.containsKey(erasedSignature)) {
          // map erased signature to substituted method
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
    }
    for (Iterator<MethodDecl> iter = typeObject().methodsIterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl) iter.next();
      if (m.isPublic() && m.erasedMethod() != m) {
        String erasedSignature = m.erasedMethod().signature();
        if (!localMap.containsKey(erasedSignature)) {
          // map erased signature to substituted method
          putSimpleSetElement(map, m.erasedMethod().signature(), m);
        }
      }
    }
    return map;
  }

  /**
   * Merge the source map into the destination map.
   * @param dest destination map
   * @param src source map
   */
  protected void TypeDecl.mergeMap(Map<String,SimpleSet> dest, Map<String,SimpleSet> src) {
    for (Map.Entry<String,SimpleSet> entry: src.entrySet()) {
      String signature = entry.getKey();
      for (Iterator iter = entry.getValue().iterator(); iter.hasNext(); ) {
        putSimpleSetElement(dest, signature, (SimpleSet) iter.next());
      }
    }
  }

  refine TypeHierarchyCheck
  public void ClassDecl.typeCheck() {
    refined();

    if (hasSuperclass()) {
      // JLS SE7 8.4.8.4
      // check for duplicate methods inherited from parameterized supertype
      if (superclass().isParameterizedType()) {
        Map<String,SimpleSet> localMap = localMethodsSignatureMap();
        Map<String,SimpleSet> methodMap = superclass().localMethodsSignatureMap();
        for (Map.Entry<String,SimpleSet> entry: methodMap.entrySet()) {
          String signature = entry.getKey();
          if (!localMap.containsKey(signature)) {
            // not locally overridden
            SimpleSet set = entry.getValue();
            Iterator iter = set.iterator();
            iter.next();
            while (iter.hasNext()) {
              MethodDecl m = (MethodDecl) iter.next();
              errorf("method with signature %s is multiply declared when inherited from %s",
                  signature, superclass().typeName());
            }
          }
        }
      }
    }
  }

  syn boolean ParTypeDecl.sameArgument(ParTypeDecl decl) {
    if (this == decl) {
      return true;
    }
    if (genericDecl() != decl.genericDecl()) {
      return false;
    }
    for (int i = 0; i < getNumArgument(); i++) {
      TypeDecl t1 = getArgument(i).type();
      TypeDecl t2 = decl.getArgument(i).type();
      if (t1 instanceof ParTypeDecl && t2 instanceof ParTypeDecl) {
        if (!((ParTypeDecl) t1).sameArgument((ParTypeDecl) t2)) {
          return false;
        }
      } else {
        if (t1 != t2) {
          return false;
        }
      }
    }
    return true;
  }

  syn lazy HashSet<InterfaceDecl> TypeDecl.implementedInterfaces() = new HashSet<InterfaceDecl>();

  eq ClassDecl.implementedInterfaces() {
    HashSet set = new HashSet();
    if (hasSuperclass()) {
      set.addAll(superclass().implementedInterfaces());
    }
    for (Iterator<TypeDecl> iter = interfacesIterator(); iter.hasNext(); ) {
      InterfaceDecl decl = (InterfaceDecl) iter.next();
      set.add(decl);
      set.addAll(decl.implementedInterfaces());
    }
    return set;
  }

  eq InterfaceDecl.implementedInterfaces() {
    HashSet<InterfaceDecl> set= new HashSet<InterfaceDecl>();
    set.addAll(typeObject().implementedInterfaces());
    for (Iterator<TypeDecl> iter = interfacesIterator(); iter.hasNext(); ) {
      InterfaceDecl decl = (InterfaceDecl) iter.next();
      set.add(decl);
      set.addAll(decl.implementedInterfaces());
    }
    return set;
  }

  public void GenericClassDecl.typeCheck() {
    super.typeCheck();
    if (instanceOf(typeThrowable())) {
      errorf("generic class %s may not directly or indirectly inherit java.lang.Throwable",
          typeName());
    }
  }

  public void GenericInterfaceDecl.typeCheck() {
    super.typeCheck();
    if (instanceOf(typeThrowable())) {
      errorf("generic interface %s may not directly or indirectly inherit java.lang.Throwable",
          typeName());
    }
  }

  inh TypeDecl GenericClassDecl.typeThrowable();
  inh TypeDecl GenericInterfaceDecl.typeThrowable();

  public void TypeAccess.typeCheck() {
    TypeDecl type = type();
    if (type.isRawType() && type.isNestedType()
        && type.enclosingType().isParameterizedType()
        && !type.enclosingType().isRawType()) {
      error("Can not access a member type of a paramterized type as a raw type");
    }
  }

  public void ParTypeAccess.typeCheck() {
    super.typeCheck();
    if (!genericDecl().isUnknown()) {
      TypeDecl type = type();
      if (!genericDecl().isGenericType()) {
        errorf("%s is not a generic type but used as one in %s",
            genericDecl().typeName(), this.prettyPrint());
      } else if (!type.isRawType() && type.isNestedType() && type.enclosingType().isRawType()) {
        error("Can not access a member type of a raw type as a parameterized type");
      } else {
        GenericTypeDecl decl = (GenericTypeDecl) genericDecl();
        GenericTypeDecl original = (GenericTypeDecl) decl.original();
        if (original.getNumTypeParameter() != getNumTypeArgument()) {
          errorf("%s takes %d type parameters, not %d as used in %s",
              decl.typeName(), original.getNumTypeParameter(), getNumTypeArgument(),
              this.prettyPrint());
        } else {
          for (int i = 0; i < getNumTypeArgument(); i++) {
            if (!getTypeArgument(i).type().withinBounds(original.getTypeParameter(i),
                (Parameterization) type())) {
              errorf("type argument %s is of type %s which is not within"
                  + " the bounds of type parameter %s (%s)",
                  i, getTypeArgument(i).type().typeName(), original.getTypeParameter(i).typeName(),
                  original.getTypeParameter(i).prettyPrint());
            }
          }
        }
      }
    }
  }

}

aspect GenericsNameBinding {

  eq ParClassDecl.getArgument().nameType() = NameType.TYPE_NAME;
  eq ParInterfaceDecl.getArgument().nameType() = NameType.TYPE_NAME;
  eq ParTypeAccess.getChild().nameType() = NameType.TYPE_NAME;

  //eq GenericClassDecl.getParTypeDecl().isNestedType() = isNestedType();
  //eq GenericClassDecl.getParTypeDecl().enclosingType() = enclosingType();
  eq GenericClassDecl.getTypeParameter().isNestedType() = true;
  eq GenericClassDecl.getTypeParameter().enclosingType() = this;

  //eq GenericInterfaceDecl.getParTypeDecl().isNestedType() = isNestedType();
  //eq GenericInterfaceDecl.getParTypeDecl().enclosingType() = enclosingType();
  eq GenericInterfaceDecl.getTypeParameter().isNestedType() = true;
  eq GenericInterfaceDecl.getTypeParameter().enclosingType() = this;

  public SimpleSet GenericTypeDecl.addTypeVariables(SimpleSet c, String name) {
    GenericTypeDecl original = (GenericTypeDecl) original();
    for (int i = 0; i < original.getNumTypeParameter(); i++) {
      TypeVariable p = original.getTypeParameter(i);
      if (p.name().equals(name)) {
        c = c.add(p);
      }
    }
    return c;
  }

  eq GenericInterfaceDecl.getSuperInterface().lookupType(String name) {
    SimpleSet c = addTypeVariables(SimpleSet.emptySet, name);
    return !c.isEmpty() ? c : lookupType(name);
  }
  eq GenericClassDecl.getSuperClass().lookupType(String name) {
    SimpleSet c = addTypeVariables(SimpleSet.emptySet, name);
    return !c.isEmpty() ? c : lookupType(name);
  }
  eq GenericClassDecl.getImplements().lookupType(String name) {
    SimpleSet c = addTypeVariables(SimpleSet.emptySet, name);
    return !c.isEmpty() ? c : lookupType(name);
  }

  eq GenericTypeDecl.getTypeParameter().lookupType(String name) {
    SimpleSet c = memberTypes(name);
    c = addTypeVariables(c, name);
    if (!c.isEmpty()) {
      return c;
    }
    // 8.5.2
    if (isClassDecl() && isStatic() && !isTopLevelType()) {
      for (Iterator iter = lookupType(name).iterator(); iter.hasNext(); ) {
        TypeDecl d = (TypeDecl) iter.next();
        if (d.isStatic() || (d.enclosingType() != null && instanceOf(d.enclosingType()))) {
          c = c.add(d);
        }
      }
    } else {
      c = lookupType(name);
    }
    if (!c.isEmpty()) {
      return c;
    }
    return topLevelType().lookupType(name); // Fix to search imports
  }
  eq GenericTypeDecl.getBodyDecl(int index).lookupType(String name) {
    SimpleSet c = memberTypes(name);
    if (getBodyDecl(index).visibleTypeParameters()) {
      c = addTypeVariables(c, name);
    }
    if (!c.isEmpty()) {
      return c;
    }
    // 8.5.2
    if (isClassDecl() && isStatic() && !isTopLevelType()) {
      for (Iterator iter = lookupType(name).iterator(); iter.hasNext(); ) {
        TypeDecl d = (TypeDecl) iter.next();
        if (d.isStatic() || (d.enclosingType() != null && instanceOf(d.enclosingType()))) {
          c = c.add(d);
        }
      }
    } else {
      c = lookupType(name);
    }
    if (!c.isEmpty()) {
      return c;
    }
    return topLevelType().lookupType(name); // Fix to search imports
    // include type parameters if not static
  }

  public void ParClassDecl.collectErrors() {
    // Disable error check for ParClassDecl which is an instanciated GenericClassDecl
  }
  public void ParInterfaceDecl.collectErrors() {
    // Disable error check for ParInterfaceDecl which is an instanciated GenericInterfaceDecl
  }

}
aspect LookupParTypeDecl {
  eq TypeVariable.fullName() {
    if (getParent().getParent() instanceof TypeDecl) {
      TypeDecl typeDecl = (TypeDecl) getParent().getParent();
      return typeDecl.fullName() + "@" + name();
    }
    return super.fullName();
  }

  syn boolean TypeDecl.sameSignature(Access a) {
    if (a instanceof ParTypeAccess) {
      return false;
    }
    if (a instanceof AbstractWildcard) {
      return false;
    }
    return this == a.type();
  }
  eq TypeVariable.sameSignature(Access a) = a.type() == this;
  syn boolean ParTypeDecl.sameSignature(Access a){
    if (a instanceof ParTypeAccess) {
      ParTypeAccess ta = (ParTypeAccess) a;
      if (genericDecl() != ta.genericDecl()) {
        return false;
      }
      if (getNumArgument() != ta.getNumTypeArgument()) {
        return false;
      }
      for (int i = 0; i < getNumArgument(); i++) {
        if (!getArgument(i).type().sameSignature(ta.getTypeArgument(i))) {
          return false;
        }
      }
      return true;
    } else if (a instanceof TypeAccess && ((TypeAccess) a).isRaw()) {
      return false;
    }
    return super.sameSignature(a);
  }
  eq RawClassDecl.sameSignature(Access a) = a instanceof TypeAccess && a.type() == this;
  eq RawInterfaceDecl.sameSignature(Access a) = a instanceof TypeAccess && a.type() == this;

  eq WildcardType.sameSignature(Access a) {
    if (a instanceof Wildcard) {
      return true;
    }
    return super.sameSignature(a);
  }
  eq WildcardExtendsType.sameSignature(Access a) {
    if (a instanceof WildcardExtends) {
      return getAccess().type().sameSignature(((WildcardExtends) a).getAccess());
    }
    return super.sameSignature(a);
  }
  eq WildcardSuperType.sameSignature(Access a) {
    if (a instanceof WildcardSuper) {
      return getAccess().type().sameSignature(((WildcardSuper) a).getAccess());
    }
    return super.sameSignature(a);
  }

  syn lazy boolean ParTypeDecl.sameSignature(java.util.List<TypeDecl> list) circular [true] {
    if (getNumArgument() != list.size()) {
      return false;
    }
    for (int i = 0; i < list.size(); i++) {
      if (getArgument(i).type() != list.get(i)) {
        return false;
      }
    }
    return true;
  }

  /** Transforms the parameter and calls the lookupParTypeDecl attribute for ArrayList arguments. */
  syn lazy TypeDecl GenericTypeDecl.lookupParTypeDecl(ParTypeAccess p) {
    Collection<TypeDecl> typeArguments = new ArrayList<TypeDecl>();
    for (int i = 0; i < p.getNumTypeArgument(); i++) {
      typeArguments.add(p.getTypeArgument(i).type());
    }
    return lookupParTypeDecl(typeArguments);
  }

  syn nta TypeDecl GenericTypeDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs);

  eq GenericClassDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs) {
    ParClassDecl typeDecl = typeArgs.size() == 0 ? new RawClassDecl() : new ParClassDecl();
    typeDecl.setModifiers((Modifiers) getModifiers().treeCopyNoTransform());
    typeDecl.setID(getID());
    // ES: trying to only do this for ParClassDecl and then later for RawClassDecl
    if (!(typeDecl instanceof RawClassDecl)) {
      typeDecl.setArgumentList(createArgumentList(typeArgs));
    }
    return typeDecl;
  }

  eq GenericInterfaceDecl.lookupParTypeDecl(Collection<TypeDecl> typeArgs) {
    ParInterfaceDecl typeDecl = typeArgs.size() == 0
        ? new RawInterfaceDecl()
        : new ParInterfaceDecl();
    typeDecl.setModifiers((Modifiers) getModifiers().treeCopyNoTransform());
    typeDecl.setID(getID());
    // ES: trying to only do this for ParInterfaceDecl and then later for RawInterfaceDecl
    if (!(typeDecl instanceof RawInterfaceDecl)) {
      typeDecl.setArgumentList(createArgumentList(typeArgs));
    }
    return typeDecl;
  }

  // TODO(jesper): remove final
  syn lazy final List RawClassDecl.getArgumentList() =
      ((GenericClassDecl) genericDecl()).createArgumentList(Collections.<TypeDecl>emptyList());

  // TODO(jesper): remove final
  syn lazy final List RawInterfaceDecl.getArgumentList() =
      ((GenericInterfaceDecl) genericDecl()).createArgumentList(Collections.<TypeDecl>emptyList());

  public List GenericTypeDecl.createArgumentList(Collection<TypeDecl> args) {
    GenericTypeDecl original = (GenericTypeDecl) original();
    List<Access> list = new List<Access>();
    if (args.isEmpty()) {
      // Change: Don't add any thing to the list.
      // Concern: The previous version seem to add the erasure of the type variable for some reason,
      // maybe this is how the raw type is represented (?), but this doesn't really comply with the
      // claim that raw types don't have any type variables...?
      for (int i = 0; i < original.getNumTypeParameter(); i++) {
        list.add(original.getTypeParameter(i).erasure().createBoundAccess());
      }
    } else {
      for (TypeDecl arg : args) {
        list.add(arg.createBoundAccess());
      }
    }
    return list;
  }

  interface Parameterization {
    boolean isRawType();
    TypeDecl substitute(TypeVariable typeVariable);
  }

  ParTypeDecl implements Parameterization;

  interface MemberSubstitutor extends Parameterization {
    TypeDecl original();
    void addBodyDecl(BodyDecl b);
    TypeDecl substitute(TypeVariable typeVariable);
  }

  ParClassDecl implements MemberSubstitutor;
  ParInterfaceDecl implements MemberSubstitutor;
  ClassDeclSubstituted implements MemberSubstitutor;
  InterfaceDeclSubstituted implements MemberSubstitutor;
  GenericClassDeclSubstituted implements MemberSubstitutor;
  GenericInterfaceDeclSubstituted implements MemberSubstitutor;

  public TypeDecl TypeDecl.substitute(TypeVariable typeVariable) {
    if (isTopLevelType()) {
      return typeVariable;
    }
    return enclosingType().substitute(typeVariable);
  }

  public TypeDecl ParTypeDecl.substitute(TypeVariable typeVariable) {
    for (int i = 0; i < numTypeParameter(); i++) {
      if (typeParameter(i) == typeVariable) {
        return getArgument(i).type();
      }
    }
    return super.substitute(typeVariable);
  }

  public TypeDecl ParMethodDecl.substitute(TypeVariable typeVariable) {
    for (int i = 0; i < numTypeParameter(); i++) {
      if (typeParameter(i) == typeVariable) {
        return getTypeArgument(i).type();
      }
    }
    return genericMethodDecl().hostType().substitute(typeVariable);
  }

  public boolean ParConstructorDecl.isRawType() {
    return false;
  }

  public TypeDecl ParConstructorDecl.substitute(TypeVariable typeVariable) {
    for (int i = 0; i < numTypeParameter(); i++) {
      if (typeParameter(i) == typeVariable) {
        return getTypeArgument(i).type();
      }
    }
    return genericConstructorDecl().hostType().substitute(typeVariable);
  }

  public int ParTypeDecl.numTypeParameter() {
    return ((GenericTypeDecl) original()).getNumTypeParameter();
  }

  public TypeVariable ParTypeDecl.typeParameter(int index) {
    return ((GenericTypeDecl) original()).getTypeParameter(index);
  }

  ParMethodDecl implements Parameterization;
  ParConstructorDecl implements Parameterization;

  public boolean ParMethodDecl.isRawType() {
    return false;
  }

  public boolean RawMethodDecl.isRawType() {
    return true;
  }

  public int ParMethodDecl.numTypeParameter() {
    return genericMethodDecl().original().getNumTypeParameter();
  }

  public int ParConstructorDecl.numTypeParameter() {
    return genericConstructorDecl().original().getNumTypeParameter();
  }

  public TypeVariable ParMethodDecl.typeParameter(int index) {
    return genericMethodDecl().original().getTypeParameter(index);
  }

  public TypeVariable ParConstructorDecl.typeParameter(int index) {
    return genericConstructorDecl().original().getTypeParameter(index);
  }

  public Access TypeDecl.substitute(Parameterization parTypeDecl) {
    if (parTypeDecl instanceof ParTypeDecl && ((ParTypeDecl) parTypeDecl).genericDecl() == this) {
      return ((TypeDecl) parTypeDecl).createBoundAccess();
    }
    if (isTopLevelType()) {
      return createBoundAccess();
    }
    return enclosingType().substitute(parTypeDecl).qualifiesAccess(new TypeAccess(name()));
  }

  public Access ArrayDecl.substitute(Parameterization parTypeDecl) {
    return new ArrayTypeAccess(componentType().substitute(parTypeDecl));
  }

  public Access TypeVariable.substitute(Parameterization parTypeDecl) {
    if (parTypeDecl.isRawType()) {
      return erasure().createBoundAccess();
    }
    return parTypeDecl.substitute(this).createBoundAccess();
  }

  public Access ParTypeDecl.substitute(Parameterization parTypeDecl) {
    // TODO: include nesting as well....
    if (parTypeDecl.isRawType()) {
      return ((GenericTypeDecl) genericDecl()).rawType().createBoundAccess();
    }
    if (!usesTypeVariable()) {
      return super.substitute(parTypeDecl);
    }
    List<Access> list = new List<Access>();
    for (Access argument : getArgumentList()) {
      //System.err.println("substituting " + argument.type().typeName() + " with " + parTypeDecl);
      list.add(argument.type().substitute(parTypeDecl));
    }
    return new ParTypeAccess(genericDecl().createQualifiedAccess(), list);
  }

  public Access RawClassDecl.substitute(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public Access RawInterfaceDecl.substitute(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public Access WildcardExtendsType.substitute(Parameterization parTypeDecl) {
    if (!usesTypeVariable()) {
      return super.substitute(parTypeDecl);
    }
    return new WildcardExtends(getAccess().type().substitute(parTypeDecl));
  }

  public Access WildcardSuperType.substitute(Parameterization parTypeDecl) {
    if (!usesTypeVariable()) {
      return super.substitute(parTypeDecl);
    }
    return new WildcardSuper(getAccess().type().substitute(parTypeDecl));
  }

  public Access TypeDecl.substituteReturnType(Parameterization parTypeDecl) {
    return substitute(parTypeDecl);
  }

  public Access ArrayDecl.substituteReturnType(Parameterization parTypeDecl) {
    return new ArrayTypeAccess(componentType().substituteReturnType(parTypeDecl));
  }

  inh TypeDecl TypeVariable.typeObject();

  syn lazy TypeDecl TypeVariable.lubType() {
    ArrayList<TypeDecl> list = new ArrayList<TypeDecl>();
    for (int i = 0; i < getNumTypeBound(); i++) {
      list.add(getTypeBound(i).type());
    }
    return lookupLUBType(list);
  }

  public Access TypeVariable.substituteReturnType(Parameterization parTypeDecl) {
    if (parTypeDecl.isRawType()) {
      return erasure().createBoundAccess();
    }
    TypeDecl typeDecl = parTypeDecl.substitute(this);
    if (typeDecl instanceof WildcardType) {
      // The bound of this type variable
      return createBoundAccess();
      //return lubType().createBoundAccess();
      //return typeObject().createBoundAccess();
    } else if (typeDecl instanceof WildcardExtendsType) {
      if (typeDecl.instanceOf(this)) {
        return ((WildcardExtendsType) typeDecl).extendsType().createBoundAccess();
      } else {
        return createBoundAccess();
      }

      // the bound of this type variable of the bound of the wild card if it is more specific
      //return ((WildcardExtendsType) typeDecl).extendsType().createBoundAccess();
    } else if (typeDecl instanceof WildcardSuperType) {
      // the bound of this type variable
      return createBoundAccess();
      //return typeObject().createBoundAccess();
    }
    return typeDecl.createBoundAccess();
  }

  public Access RawClassDecl.substituteReturnType(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public Access RawInterfaceDecl.substituteReturnType(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public Access TypeDecl.substituteParameterType(Parameterization parTypeDecl) {
    return substitute(parTypeDecl);
  }

  inh TypeDecl TypeVariable.typeNull();
  public Access TypeVariable.substituteParameterType(Parameterization parTypeDecl) {
    if (parTypeDecl.isRawType()) {
      return erasure().createBoundAccess();
    }
    TypeDecl typeDecl = parTypeDecl.substitute(this);
    if (typeDecl instanceof WildcardType) {
      return typeNull().createQualifiedAccess();
    } else if (typeDecl instanceof WildcardExtendsType) {
      return typeNull().createQualifiedAccess();
    } else if (typeDecl instanceof WildcardSuperType) {
      return ((WildcardSuperType) typeDecl).superType().createBoundAccess();
    }
    return typeDecl.createBoundAccess();
  }

  public Access RawClassDecl.substituteParameterType(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public Access RawInterfaceDecl.substituteParameterType(Parameterization parTypeDecl) {
    return createBoundAccess();
  }

  public List List.substitute(Parameterization parTypeDecl) {
    List list = new List();
    for (int i = 0; i < getNumChild(); i++) {
      ASTNode node = getChild(i);
      if (node instanceof Access) {
        Access a = (Access) node;
        list.add(a.type().substitute(parTypeDecl));
      } else if (node instanceof VariableArityParameterDeclaration) {
        VariableArityParameterDeclaration p = (VariableArityParameterDeclaration) node;
        list.add(
          new VariableArityParameterDeclarationSubstituted(
            (Modifiers) p.getModifiers().treeCopyNoTransform(),
            // use the type acces since VariableArity adds to the dimension
            p.getTypeAccess().type().substituteParameterType(parTypeDecl),
            p.getID(),
            p
          )
        );
      } else if (node instanceof ParameterDeclaration) {
        ParameterDeclaration p = (ParameterDeclaration) node;
        list.add(
          new ParameterDeclarationSubstituted(
            (Modifiers) p.getModifiers().treeCopyNoTransform(),
            p.type().substituteParameterType(parTypeDecl),
            p.getID(),
            p
          )
        );
      } else {
        throw new Error("Can only substitute lists of access nodes but node number "
            + i + " is of type " + node.getClass().getName());
      }
    }
    return list;
  }

  syn lazy Opt ParClassDecl.getSuperClassOpt() {
    GenericClassDecl decl = (GenericClassDecl) genericDecl();
    Opt opt;
    //System.err.println("Begin substituting extends clause");
    if (decl.hasSuperClass()) {
      opt = new Opt((decl.getSuperClass().type().substitute(this)));
    } else {
      opt = new Opt();
    }
    //System.err.println("End substituting extends clause");
    return opt;
  }

  syn lazy List ParClassDecl.getImplementsList() {
    GenericClassDecl decl = (GenericClassDecl) genericDecl();
    //System.err.println("Begin substituting implements list");
    List list = decl.getImplementsList().substitute(this);
    //System.err.println("End substituting implements list");
    return list;
  }

  syn lazy List ParClassDecl.getBodyDeclList() = new BodyDeclList();

  syn lazy List ParInterfaceDecl.getSuperInterfaceList() {
    GenericInterfaceDecl decl = (GenericInterfaceDecl) genericDecl();
    //System.err.println("Begin substituting implements list");
    List list = decl.getSuperInterfaceList().substitute(this);
    //System.err.println("End substituting implements list");
    return list;
  }

  syn lazy List ParInterfaceDecl.getBodyDeclList() = new BodyDeclList();

  syn lazy List ClassDeclSubstituted.getBodyDeclList() = new BodyDeclList();
  syn lazy List InterfaceDeclSubstituted.getBodyDeclList() = new BodyDeclList();
  syn lazy List GenericClassDeclSubstituted.getBodyDeclList() = new BodyDeclList();
  syn lazy List GenericInterfaceDeclSubstituted.getBodyDeclList() = new BodyDeclList();


  syn boolean ASTNode.usesTypeVariable() {
    for (int i = 0; i < getNumChild(); i++) {
      if (getChild(i).usesTypeVariable()) {
        return true;
      }
    }
    return false;
  }

  syn lazy boolean MethodDecl.usesTypeVariable() =
      getModifiers().usesTypeVariable() || getTypeAccess().usesTypeVariable()
      || getParameterList().usesTypeVariable() || getExceptionList().usesTypeVariable();

  syn lazy boolean FieldDeclaration.usesTypeVariable() = getTypeAccess().usesTypeVariable();

  eq TypeAccess.usesTypeVariable() = decl().usesTypeVariable() || super.usesTypeVariable();

  syn lazy boolean TypeDecl.usesTypeVariable() circular [false] =
      isNestedType() && enclosingType().usesTypeVariable();

  eq ParTypeDecl.usesTypeVariable() {
    if (super.usesTypeVariable()) {
      return true;
    }
    for (int i = 0; i < getNumArgument(); i++)
      if (getArgument(i).type().usesTypeVariable()) {
        return true;
      }
    return false;
  }

  eq GenericClassDecl.usesTypeVariable() = true;
  eq GenericInterfaceDecl.usesTypeVariable() = true;
  eq TypeVariable.usesTypeVariable() = true;
  eq WildcardExtendsType.usesTypeVariable() = getAccess().type().usesTypeVariable();
  eq WildcardSuperType.usesTypeVariable() = getAccess().type().usesTypeVariable();
  eq ArrayDecl.usesTypeVariable() = elementType().usesTypeVariable();

  syn lazy final Map<String,SimpleSet> MemberSubstitutor.localMethodsSignatureMap() {
    Map<String,SimpleSet> map = new HashMap<String,SimpleSet>();
    for (Iterator<MethodDecl> iter = original().localMethodsIterator(); iter.hasNext(); ) {
      MethodDecl decl = iter.next();

      if (!decl.isStatic() && (decl.usesTypeVariable() || isRawType())) {
        BodyDecl copyDecl = ((BodyDeclList) getBodyDeclList()).localMethodSignatureCopy(decl, this);
        decl = (MethodDecl) copyDecl;
      }
      putSimpleSetElement(map, decl.signature(), decl);

    }
    return map;
  }

  syn nta BodyDecl BodyDeclList.localMethodSignatureCopy(MethodDecl originalMethod,
      MemberSubstitutor m) = originalMethod.substitutedBodyDecl(m);

  syn lazy final SimpleSet MemberSubstitutor.localFields(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for (Iterator iter = original().localFields(name).iterator(); iter.hasNext(); ) {
      FieldDeclaration f = (FieldDeclaration) iter.next();

      if (!f.isStatic() && (f.usesTypeVariable() || isRawType())) {
        BodyDecl fCopy = ((BodyDeclList) getBodyDeclList()).localFieldCopy(f, this);
        f = (FieldDeclaration) fCopy;
      }
      set = set.add(f);

    }
    return set;
  }

  syn nta BodyDecl BodyDeclList.localFieldCopy(FieldDeclaration originalDecl, MemberSubstitutor m) =
      originalDecl.substitutedBodyDecl(m);

  // TODO-ES: Add NTA for copies like above
  syn lazy final SimpleSet MemberSubstitutor.localTypeDecls(String name) circular [SimpleSet.emptySet] {
    SimpleSet set = SimpleSet.emptySet;
    for (Iterator iter = original().localTypeDecls(name).iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl) iter.next();

      if (t.isStatic()) {
        set = set.add(t);
      } else if (t instanceof ClassDecl) {
        MemberClassDecl copy =
          ((BodyDeclList) getBodyDeclList()).localClassDeclCopy((ClassDecl) t, this);
        set = set.add(copy.getClassDecl());
      } else if (t instanceof InterfaceDecl) {
        MemberInterfaceDecl copy =
          ((BodyDeclList) getBodyDeclList()).localInterfaceDeclCopy((InterfaceDecl) t, this);
        set = set.add(copy.getInterfaceDecl());
      }
    }
    return set;
  }

  // ES: adding NTA to store copies in
  syn nta MemberClassDecl BodyDeclList.localClassDeclCopy(ClassDecl originalDecl, MemberSubstitutor m) {
    ClassDecl copy = originalDecl.substitutedClassDecl(m);
    return new MemberClassDecl(copy);
  }

  syn nta MemberInterfaceDecl BodyDeclList.localInterfaceDeclCopy(InterfaceDecl originalDecl,
      MemberSubstitutor m) {
    InterfaceDecl copy = originalDecl.substitutedInterfaceDecl(m);
    return new MemberInterfaceDecl(copy);
  }

  syn lazy Collection<ConstructorDecl> MemberSubstitutor.constructors() {
    Collection<ConstructorDecl> constructors = new ArrayList<ConstructorDecl>();
    for (Iterator iter = original().constructors().iterator(); iter.hasNext(); ) {
      ConstructorDecl c = (ConstructorDecl) iter.next();

      ConstructorDecl b = ((BodyDeclList) getBodyDeclList()).constructorCopy(c, this);
      constructors.add(b);
    }
    return constructors;
  }

  syn nta ConstructorDecl BodyDeclList.constructorCopy(ConstructorDecl originalDecl,
      MemberSubstitutor m) = originalDecl.substitutedBodyDecl(m);

  public BodyDecl BodyDecl.substitutedBodyDecl(Parameterization parTypeDecl) {
    throw new Error("Operation substitutedBodyDecl not supported for " + getClass().getName());
  }

  public BodyDecl MethodDecl.substitutedBodyDecl(Parameterization parTypeDecl) {
    MethodDecl m = new MethodDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getTypeAccess().type().substituteReturnType(parTypeDecl),
      getID(),
      getParameterList().substitute(parTypeDecl),
      getExceptionList().substitute(parTypeDecl),
      substituteBody(parTypeDecl),
      this
    );
    return m;
  }

  public Opt MethodDecl.substituteBody(Parameterization parTypeDecl) {
    return new Opt();
  }

  syn GenericMethodDecl GenericMethodDecl.original() = original != null ? original : this;
  public GenericMethodDecl GenericMethodDecl.original;

  syn GenericConstructorDecl GenericConstructorDecl.original() = original != null ? original : this;
  public GenericConstructorDecl GenericConstructorDecl.original;

  public ConstructorDecl ConstructorDecl.substitutedBodyDecl(Parameterization parTypeDecl) {
    return new ConstructorDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getID(),
      getParameterList().substitute(parTypeDecl),
      getExceptionList().substitute(parTypeDecl),
      new Opt(),
      new Block(),
      this
    );
  }

  public BodyDecl FieldDeclaration.substitutedBodyDecl(Parameterization parTypeDecl) {
    return new FieldDeclarationSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getTypeAccess().type().substituteReturnType(parTypeDecl),
      getID(),
      new Opt(),
      this
    );
  }

  syn FieldDeclaration FieldDeclaration.erasedField() = this;
  eq FieldDeclarationSubstituted.erasedField() = getOriginal().erasedField();

  syn MethodDecl MethodDecl.erasedMethod() = this;
  eq MethodDeclSubstituted.erasedMethod() = getOriginal().erasedMethod();
  eq ParMethodDecl.erasedMethod() = genericMethodDecl().erasedMethod();

  syn TypeDecl TypeDecl.original() = this;
  eq ClassDeclSubstituted.original() = getOriginal().original();
  eq InterfaceDeclSubstituted.original() = getOriginal().original();
  eq GenericClassDeclSubstituted.original() = getOriginal().original();
  eq GenericInterfaceDeclSubstituted.original() = getOriginal().original();
  eq ParTypeDecl.original() = genericDecl().original();

  public ClassDecl ClassDecl.substitutedClassDecl(Parameterization parTypeDecl) {
    return new ClassDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getID(),
      hasSuperClass() ? new Opt(getSuperClass().type().substitute(parTypeDecl)) : new Opt(),
      getImplementsList().substitute(parTypeDecl),
      this
    );
  }

  public ClassDecl GenericClassDecl.substitutedClassDecl(Parameterization parTypeDecl) {
    return new GenericClassDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getID(),
      hasSuperClass() ? new Opt(getSuperClass().type().substitute(parTypeDecl)) : new Opt(),
      getImplementsList().substitute(parTypeDecl),
      new List(), // delegates TypeParameter lookup to original
      this
    );
  }

  public InterfaceDecl InterfaceDecl.substitutedInterfaceDecl(Parameterization parTypeDecl) {
    return new InterfaceDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getID(),
      getSuperInterfaceList().substitute(parTypeDecl),
      this
    );
  }

  public InterfaceDecl GenericInterfaceDecl.substitutedInterfaceDecl(Parameterization parTypeDecl) {
    return new GenericInterfaceDeclSubstituted(
      (Modifiers) getModifiers().treeCopyNoTransform(),
      getID(),
      getSuperInterfaceList().substitute(parTypeDecl),
      new List(), // delegates TypeParameter lookup to original
      this
    );
  }

  syn nta WildcardsCompilationUnit Program.wildcards() {
    return new WildcardsCompilationUnit(
      "wildcards",
      new List(),
      new List()
    );
  }

  syn TypeDecl WildcardExtendsType.extendsType() = getAccess().type();
  syn TypeDecl WildcardSuperType.superType() = getAccess().type();

  eq Wildcard.type() = typeWildcard();
  eq WildcardExtends.type() = lookupWildcardExtends(getAccess().type());
  eq WildcardSuper.type() = lookupWildcardSuper(getAccess().type());
  inh TypeDecl WildcardSuper.lookupWildcardSuper(TypeDecl typeDecl);
  inh TypeDecl WildcardExtends.lookupWildcardExtends(TypeDecl typeDecl);
  inh TypeDecl Wildcard.typeWildcard();

  syn nta TypeDecl WildcardsCompilationUnit.typeWildcard() =
      new WildcardType(
          new Modifiers(new List().add(new Modifier("public"))),
          "?",
          new List());

  inh TypeDecl TypeDecl.typeWildcard();

  eq Program.getChild().typeWildcard() = wildcards().typeWildcard();

  syn nta TypeDecl WildcardsCompilationUnit.lookupWildcardExtends(TypeDecl bound) =
      new WildcardExtendsType(
          new Modifiers(new List().add(new Modifier("public"))),
          "? extends " + bound.fullName(),
          new List(),
          bound.createBoundAccess());

  eq Program.getChild().lookupWildcardExtends(TypeDecl typeDecl) =
      wildcards().lookupWildcardExtends(typeDecl);

  inh TypeDecl TypeDecl.lookupWildcardExtends(TypeDecl typeDecl);

  syn TypeDecl TypeDecl.asWildcardExtends() = lookupWildcardExtends(this);

  syn nta TypeDecl WildcardsCompilationUnit.lookupWildcardSuper(TypeDecl bound) =
      new WildcardSuperType(
          new Modifiers(new List().add(new Modifier("public"))),
          "? super " + bound.fullName(),
          new List(),
          bound.createBoundAccess());

  eq Program.getChild().lookupWildcardSuper(TypeDecl typeDecl) =
      wildcards().lookupWildcardSuper(typeDecl);

  inh TypeDecl TypeDecl.lookupWildcardSuper(TypeDecl typeDecl);

  syn TypeDecl TypeDecl.asWildcardSuper() = lookupWildcardSuper(this);

  syn nta LUBType WildcardsCompilationUnit.lookupLUBType(Collection bounds) = createLUBType(bounds);

  public static LUBType WildcardsCompilationUnit.createLUBType(Collection bounds) {
    List boundList = new List();
    StringBuilder name = new StringBuilder();
    for (Iterator iter = bounds.iterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl) iter.next();
      boundList.add(typeDecl.createBoundAccess());
      name.append("& " + typeDecl.typeName());
    }
    LUBType decl = new LUBType(
      new Modifiers(new List().add(new Modifier("public"))),
      name.toString(),
      new List(),
      boundList
    );
    return decl;
  }

  inh LUBType TypeDecl.lookupLUBType(Collection bounds);

  eq Program.getChild().lookupLUBType(Collection bounds) = wildcards().lookupLUBType(bounds);

  syn String LUBType.typeName() {
    if (getNumTypeBound() == 0) {
      return "<NOTYPE>";
    }
    StringBuilder sb = new StringBuilder();
    sb.append(getTypeBound(0).type().typeName());
    for (int i = 1; i < getNumTypeBound(); i++) {
      sb.append(" & " + getTypeBound(i).type().typeName());
    }
    return sb.toString();
  }

  public HashSet LUBType.implementedInterfaces(){
       HashSet ret = new HashSet();
       for (int i = 0; i < getNumTypeBound(); i++) {
           ret.addAll(getTypeBound(i).type().implementedInterfaces());
       }
       return ret;
   }

  syn nta GLBType WildcardsCompilationUnit.lookupGLBType(ArrayList bounds) {
    List boundList = new List();
    StringBuilder name = new StringBuilder();
    for (Iterator iter = bounds.iterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl) iter.next();
      boundList.add(typeDecl.createBoundAccess());
      name.append("& " + typeDecl.typeName());
    }
    GLBType decl = new GLBType(
      new Modifiers(new List().add(new Modifier("public"))),
      name.toString(),
      new List(),
      boundList
    );
    return decl;
  }

  inh GLBType TypeDecl.lookupGLBType(ArrayList bounds);

  eq Program.getChild().lookupGLBType(ArrayList bounds) = wildcards().lookupGLBType(bounds);

  syn String GLBType.typeName() {
    if (getNumTypeBound() == 0) {
      return "<NOTYPE>";
    }
    StringBuilder sb = new StringBuilder();
    sb.append(getTypeBound(0).type().typeName());
    for (int i = 1; i < getNumTypeBound(); i++) {
      sb.append(" & " + getTypeBound(i).type().typeName());
    }
    return sb.toString();
  }

  public HashSet GLBType.implementedInterfaces(){
    HashSet ret = new HashSet();
    for (int i = 0; i < getNumTypeBound(); i++) {
      ret.addAll(getTypeBound(i).type().implementedInterfaces());
    }
    return ret;
  }

}

aspect NewGenerics {

  public Access TypeVariable.createQualifiedAccess() {
    return createBoundAccess();
  }

  eq TypeVariable.accessibleFrom(TypeDecl type) = true;

  eq TypeVariable.typeName() = name();
}

aspect SourceDeclarations {
  syn lazy TypeDecl TypeDecl.sourceTypeDecl() = this;
  eq ParTypeDecl.sourceTypeDecl() = genericDecl().original().sourceTypeDecl();
  eq ClassDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq InterfaceDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq GenericClassDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();
  eq GenericInterfaceDeclSubstituted.sourceTypeDecl() = original().sourceTypeDecl();

  syn lazy MethodDecl MethodDecl.sourceMethodDecl() = this;
  eq ParMethodDecl.sourceMethodDecl() = genericMethodDecl().original().sourceMethodDecl();
  eq MethodDeclSubstituted.sourceMethodDecl() = getOriginal().sourceMethodDecl();

  syn lazy ConstructorDecl ConstructorDecl.sourceConstructorDecl() = this;

  eq ParConstructorDecl.sourceConstructorDecl() =
      genericConstructorDecl().original().sourceConstructorDecl();

  eq ConstructorDeclSubstituted.sourceConstructorDecl() =
      getOriginal().sourceConstructorDecl();

  syn lazy Variable Variable.sourceVariableDecl();
  eq VariableDeclaration.sourceVariableDecl() = this;
  eq FieldDeclaration.sourceVariableDecl() = this;
  eq FieldDeclarationSubstituted.sourceVariableDecl() = getOriginal().sourceVariableDecl();
  eq ParameterDeclaration.sourceVariableDecl() = this;
  eq ParameterDeclarationSubstituted.sourceVariableDecl() = getOriginal().sourceVariableDecl();

}
